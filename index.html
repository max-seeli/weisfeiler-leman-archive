<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Weisfeiler-Leman Archive</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/vis-network/9.1.2/dist/dist/vis-network.min.css" integrity="sha512-WgxfT5LWjfszlPHXRmBWHkV2eceiWTOBvrKCNbdgDYTHrT2AeLCGbF4sZlZw3UMN3WtL0tGUoIAKsu8mllg/XA==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/vis-network/9.1.2/dist/vis-network.min.js" integrity="sha512-LnvoEWDFrqGHlHmDD2101OrLcbsfkrzoSpvtSQtxK3RMnRV0eOkhhBN2dXHKRrUU8p2DGRTk35n4O8nWSVe1mQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script type="module" src="https://unpkg.com/@splinetool/viewer@1.0.91/build/spline-viewer.js"></script>
</head>
<body>
    <header>
    <div class="container">
        <div class="text-container">
        <h1>Weisfeiler-Leman Archive</h1>
        <p>Welcome to the Weisfeiler-Leman Archive, a collection dedicated to showcasing graphs that are non-isomorphic yet cannot be distinguished by the Weisfeiler-Leman isomorphism test. This archive serves as a resource for researchers, students, and anyone interested in graph theory and its complexities.</p>
        </div>
        <spline-viewer class="spline-viewer-large" loading-anim-type="spinner-small-light" url="https://prod.spline.design/vHZarVWNI6MUXm8r/scene.splinecode"></spline-viewer>

        <spline-viewer class="spline-viewer-small" loading-anim-type="spinner-small-light" url="https://prod.spline.design/MxCT02FhS2OJEASh/scene.splinecode"></spline-viewer>
    </div>
        <div class="scroll-arrow">
            <i class="fas fa-chevron-down"></i>
        </div>
    </header>

    <section id="graphs-section">
    <h2 id="graphs">Graphs</h2>
    <main id="graph-container">

    </main>
    </section>

    <script>

        const textToList = (str) => {
            const modifiedStr = str.replace(/\(/g, '[').replace(/\)/g, ']');
            const list = JSON.parse(modifiedStr);
            return list;
        }

        const toNetwork = (edgeList) => {
            const nodes = new vis.DataSet();
            const edges = new vis.DataSet();

            edgeList.forEach(([from, to]) => {
                [from, to].forEach((node) => {
                    if (!nodes.get(node)) {
                        nodes.add({ id: node, label: node.toString() });
                    }
                });

                edges.add({ from, to });
            })

            return { nodes, edges };
        }

        const createNetworkPair = (graph1, graph2, options = {}) => {

            const graphPair = document.createElement('div');
            graphPair.className = 'graph-pair';

            [graph1, graph2].forEach(graph => {
                const graphElement = document.createElement('div');
                graphElement.className = 'graph';
                graphPair.appendChild(graphElement);

                new vis.Network(graphElement, graph, options);
            })

            return graphPair;
        }

        const loadGraphs = async () => {
            try {
                const response = await fetch('collisions/graphs.txt')
                const text = await response.text();

                // Split the text by lines and filter out any empty lines
                const lines = text.split('\n').filter(line => line.trim() !== '');
                const collisions = [];

                for (let i = 0; i < lines.length; i += 2) {
                    const graph1 = toNetwork(textToList(lines[i]));
                    const graph2 = toNetwork(textToList(lines[i + 1]));
                    collisions.push([graph1, graph2]);
                }

                const container = document.getElementById('graph-container');

                collisions.forEach(([graph1, graph2]) => {
                    const networkPair = createNetworkPair(graph1, graph2);
                    container.appendChild(networkPair);
                });
            } catch (error) {
                console.error('Failed to load or process the graphs:', error);
            }
        }

        loadGraphs();

        // Listen for scroll events on the window
        window.addEventListener('scroll', function() {
            const header = document.querySelector('header');
            const graphsSection = document.getElementById('graphs-section');

            const headerBottom = header.offsetTop + header.offsetHeight;

            graphsSection.style.position = 'absolute';
            graphsSection.style.top = `${headerBottom}px`;
        });



    </script>
</body>
</html>
